function solution(number, limit, power) {
    var arr = [];
    //약수는 자신 자신으로 나눠지는 것도 포함하기에 증감하면서
    // 본인 수로 나눠지는 경우의 수를 위하여 <= 비교 연산자 사용
    for(let i = 1;i<=number;i++) {
        var answer = 0;
        // i의 약수를 찾기 위한 반복문
        // 시간복잡도를 고려하지 않으면, 큰 수가 들어왔을 떄 이중 반복으로 인하여
        // 시간 복잡도가 너무 높아짐.
        // 따라서 약수를 빨리 찾을 수 있는 로직을 생각해야함 
        for (let j = 1;j*j<=i;j++) {
            if(i % j === 0) {
              answer++;   
               if (j * j != i) {
                answer++; // i / j도 i의 약수
            }
            } 
        }
        //약수의 개수가 Limit 값보다 크면, 초과한 기사 사용할 무기 공격력을 배열에 넣어줌
        // 안크면 그냥 원래 있는 약수 개수(공격력)을 배열에 그대로 넣어줌
        arr.push(answer > limit ? power : answer);
    }
    
    
    //reduce 함수를 기억하자 ES6에서 도입되어, 배열의 모든 요소를 단일 값으로 줄일 수 있도록
    //도와주는 함수이다. 
    
    //위에서 이미 공격력을 초과한 기사들에 한하여, 협회에서 제한한 공격력을 배열에 넣어줬기에
    // 문제에서 제시하고 있는 필요한 철의 무게를 return 하기 위해서는
    // 모든 배열의 합을 구하면 된다.
    
    //reduce 함수 첫번째 매개 변수 - 사용자 정의 콜백 함수 
    // 콜백 함수는 두가지 필수 매개변수를 요구합니다 accumulator누산기 와
    // currentValue 현재 루프 돌고 있는 배열의 각 요소 값입니다 .
    // 즉 합산을 위해서는 누산기에 현재 루프 돌고있는 배열에 값 요소를 다 더해줘야죠.
    // reduce 함수 두번쨰 매개 변수 - 처음 루프에 accumulator 누산기 값으로 넘길 초기값 입니다. 
    // 저 값을 2나 다른 숫자로 주게 되면 처음 합이 2부터 시작이겠죠.
    return arr.reduce((acc,current) => { return acc + current},0);
}